B+树的基本性质：（请自学了解本题内容，不需要回答）
数据结构；
随机查找算法；
范围查找算法；
索引项插入算法；
索引项删除算法

在B+树上存在哪几种封锁粒度？他们之间的关系是什么？
index entries locking  and  key-range locking  
封锁一个索引项（index entry lock）就相当于封锁其对应的索引关键字区间（key range lock）

什么是lock coupling？在索引封锁的实现中，为什么要引入lock coupling机制？

ReadLock 仅仅用于查询（即以‘只读’方式访问索引树的各个结点），请参考B+树上查找算法的执行流程。一般流程如下（详见下一页的流程图）
输入：随机查找关键字K
1、从根结点开始 ，自顶向下搜索到某个叶子结点；
2、在每一个结点中，根据其中保存的关键字值，将整个关键字的值域划分为若干个‘取值区间’
3、如果当前结点不是叶子结点，则判断关键字K属于哪一个取值区间，从而决定下一个要访问的索引结点（index page）。
      当然，我们从当前结点（被称为’结点P'）找到的是‘下一个将要被访问的索引结点（被称为‘结点C'）的结点指针’（结点P和结点C互为‘父子’关系）
      在根据找到的结点指针访问‘下一个’结点C之前，我们先要申请结点C上的ReadLock
      在获得结点C上的ReadLock封锁后，当前事务就获得了对于结点C的访问权限，并且之后不需要再回溯访问其父结点P
      所以，当前事务在获得子结点C上的ReadLock后，就可以立即释放其父结点P上的ReadLock
      这样的封锁使用方式并不符合‘两阶段封锁’协议的要求，但适合于数据库中的 B+ 索引的访问特点
      因此，为了提高效率，在B+树结点上的ReadLock的申请和释放都是这样成对出现的，这被称为‘锁耦合’（lock coupling）
4、如果当前结点是叶子结点，就搜索当前页面中是不是有关键字K。
      1）如果在当前叶子结点中没有关键字K，则表明K对应的元组不存在，则以失败方式返回并释放当前叶子结点上的ReadLock; （如果是范围查找，则需要顺序扫描当前叶子结点中是否有其他符合条件的关键字，具体请参见B+树上范围查找算法）
      2）如果存在，则以ReadLock方式封锁K对应的索引项（key-rangle lock），释放当前结点上的ReadLock，返回查找成功；

简述在B+树上的ReadLock的申请处理流程。
简述在B+树上的WriteLock的申请处理流程。



7.C
8.A
9.C


bcd 
c
b
b
c
6.1 申请a的ReadLock，申请b的ReadLock,释放a的ReadLock，申请f的ReadLock，释放b的ReadLock，申请14的ReadLock，释放f的ReadLock
6.2 申请a的WriteLock，申请b的WriteLock，申请g的WriteLock，释放a,b的WriteLock，释放g的WriteLock
